---
title: "Hands-on Exercise 1"
author: "Shawn Tan"
---

# Getting Started

## Install and launching R packages

The code chunk below uses p_load() of pacman package to check if sf and tidyverse packages are installed in the computer. If they are, then they will be launched into R.

```{r}
pacman::p_load(sf, tidyverse)
```

## Datasets

The following datasets will be used:

-   **MP14_SUBZONE_WEB_PL**, a polygon feature layer in ESRI shapefile format ([Master Plan 2014 Subzone Boundary](https://data.gov.sg/datasets?query=Master+Plan+2014+Subzone+Boundary+(Web)&page=1&resultId=d_5cb80a95445f236737f6bc2bfe5f159d))

-   **CyclingPath**, a line feature layer in ESRI shapefile format ([Cycling Path](https://datamall.lta.gov.sg/content/dam/datamall/datasets/Geospatial/CyclingPath_Apr2025.zip))

-   **PreSchool**, a point feature layer in kml file format ([Pre-Schools Location](https://data.gov.sg/datasets?query=Pre-Schools+Location&page=1&resultId=d_61eefab99958fd70e6aab17320a71f1c))

-   Latest Airbnb Singapore Listing Data ([Inside Airbnb](https://insideairbnb.com/get-the-data/))

## Importing the data

*st_read()* function of the **sf** package will be used to import **MP14_SUBZONE_WEB_PL** shapefile into mpsz.

```{r}
mpsz = st_read(dsn = "data/geospatial", 
                  layer = "MP14_SUBZONE_WEB_PL")
```

The same function will be used to import the **CyclingPath** shapefile into cyclingpath as well.

```{r}
cyclingpath = st_read(dsn = "data/geospatial", 
                         layer = "CyclingPathGazette")
```

Since the PreSchool file is in [**kml**](https://en.wikipedia.org/wiki/Keyhole_Markup_Language) format. The code chunk below will be used to import the kml into R.

```{r}
preschool = st_read("data/geospatial/PreSchoolsLocation.kml")
```

## Checking the contents of the dataframe

*st_geometry()* extracts or set the geometry column of the object. In this case, we are accessing the spatial information stored in our objects.

The following code chunk is what we will use to extract from mpsz.

```{r}
st_geometry(mpsz)
```

Besides the basic geospatial feature information, we also would like to learn more about the associated attribute information stored in our data frame. We will use *glimpse()* to show more information of our mpsz object.

```{r}
glimpse(mpsz)
```

Sometimes we would like a quick look/preview of our object. In this case, we can use *head()* to preview both the attribute information and geometry values without printing the entire dataset.

```{r}
head(mpsz, n=5)  
```

## Plotting the Data

We will now turn our attention to visualising the spatial features. Using *plot()* will give us a way to render the geospatial features stored in our object. By plotting the geometry, we will be able to see the shapes and boundaries that is in our data.

```{r}
plot(mpsz)
```

As shown, it has plotted all the attributes in our object. If we want to plot only the geometry outline, we will have to use the following code chunk.

```{r}
plot(st_geometry(mpsz))
```

We may also want to plot specific attributes from our object. In this case we can select the specific attribute that we would like to plot.

```{r}
plot(mpsz["PLN_AREA_N"])
```

We also may want to plot multiple layers to have more visualisation. In that case we can use the following chunk code which plots the preschool layer on top of the mpsz layer.

```{r}
plot(st_geometry(mpsz))
plot(st_geometry(preschool), 
     add = TRUE)
```

The preschool layer is not shown in this example. This is because the EPSG codes are different and each layer is using a different CRS format.

To ensure correct visualisation and analysis, it is necessary to transform all layers into a common CRS before plotting or overlaying them.

### **Assigning EPSG code to a simple feature data frame**

As shown above, the issue is due to the layers using different CRS format. We will proceed to check the CRS format of our mpsz using the following code chunk

```{r}
st_crs(mpsz)
```

Although the mpsz data frame shows SVY21, it shows that its EPSG code is 9001. Since the EPSG code should be 3414, we will proceed to assign the correct EPSG code using the following code chunk.

```{r}
mpsz <- st_set_crs(mpsz, 3414)
```

With that done, we can check the EPSG code again.

```{r}
st_crs(mpsz)
```

EPSG code is now 3414.

### **Transforming the projection of preschool from WGS84 to SVY21**

As mentioned above, a common CRS is required. Without a common CRS, two layers plotted together will not align. As a result, features that should overlap may instead appear far apart or not visible in the same plotting window.

By ensuring a common CRS across all layers, we guarantee that every coordinate is interpreted in the same “language,” allowing features to align properly on the map.

We will proceed to transform the CRS for preschool to SVY21 with the following code chunk

```{r}
preschool <- st_transform(preschool, 
                              crs = 3414)
```

With that done, we can now proceed to plot the layers.

```{r}
plot(st_geometry(mpsz))
plot(st_geometry(preschool), add = TRUE)
```

Both layers have been plotted properly.

## **Importing and Converting An Aspatial Data**

### **Importing the aspatial data**

We will now proceed to import the listings data from the Airbnb csv file.

```{r}
listings <- read_csv("data/aspatial/listings.csv")
```

Previously, we used *glimpse()* to view our object which showed both attribute values and their data types.

However, when we first import a CSV, it is not yet a spatial object. *list()* will allows use to view the object's contents or structure in R’s base style. We can later apply *glimpse()* once the data is prepared for further analysis.

```{r}
list(listings) 
```

After checking the information is correct, we can now choose to convert it into a dataframe.

### **Creating a simple feature data frame from an aspatial data frame**

The code chunk below converts the listing data frame into a simple feature data frame by using *st_as_sf()* of **sf** packages.

```{r}
listings_sf <- st_as_sf(listings, 
                       coords = c("longitude", "latitude"),
                       crs=4326) %>%
  st_transform(crs = 3414)
```

We may now view the data using *glimpse()*.

```{r}
glimpse(listings_sf)
```

With this, we can now plot the listings layer onto the mpsz layer using the following code chunk.

```{r}
plot(st_geometry(mpsz))
plot(st_geometry(listings_sf), add = TRUE)
```

## **Geoprocessing with sf package**

### **Land acquisition analysis**

#### Scenario

The authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the existing cycling path. You are tasked to determine the extend of the land need to be acquired and their total area.

#### Solution

The function *st_buffer()* creates a new geometry by expanding (or contracting, if negative) the boundaries of existing features by a specified distance. The distance is measured in the units of the dataset’s CRS.

```{r}
cyclingpath <- st_transform(cyclingpath, st_crs(mpsz))
buffer_cycling <- st_buffer(
  cyclingpath, dist=5, nQuadSegs = 30)
```

dist = 5 creates a buffer distance of 5 units around each cycling path.

nQuadSegs = 30 controls the smoothening of the curves. The higher the value, the smoother it is.

Newly created buffer_cycling object contains polygons representing the buffered zones around each path with the same CRS as mpsz.

Calculating the area of the buffers as shown in the code chunk below.

```{r}
buffer_cycling$AREA <- st_area(buffer_cycling)
```

Lastly, *sum()* of Base R will be used to derive the total land involved.

```{r}
sum(buffer_cycling$AREA)
```

We can also create a plot showing the buffer by a selected planning subzone.

Assuming that we are interested on the land acquisition in Tampines West planning subzone.

Firstly, *filter()* of dplyr package will be used to extract polygon feature of Tampines West by using the code chunk below.

```{r}
mpsz_selected <- mpsz %>%
  filter(SUBZONE_N == "TAMPINES WEST") 
```

Next, *st_intersection()* of sf package will be used to clip cycling buffers within Tampines West planning subzone.

*st_intersection()* clips the cycling buffers so that only the parts within Tampines West remain

```{r}
buffer_cycling_selected <- st_intersection(
  buffer_cycling, mpsz_selected)
```

Afterwhich we plot the the selected area.

```{r}
plot(st_geometry(buffer_cycling_selected))
```

### **To determine the number of pre-schools by planning subzone**

#### Scenario

The authority requires a count of pre-schools for each planning subzone to support forward planning. Using R and the sf package, perform the necessary geoprocessing to compute these counts and present the results clearly.

#### Solution

The code chunk below performs two operations at one go. Firstly, identify pre-schools located inside each Planning Subzone by using *st_intersects()*. Next, *length()* of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.

*st_intersects()* returns us the features that intersect. This refers when two layers touch or overlap each other.

Since the output of *st_intersects()* is a list, to summarise the results, we use *length()* to return the number of elements in an object which shows us the number of preschools that are within a subzone found from the result of *st_intersects()*.

```{r}
mpsz$`PreSch Count`<- lengths(st_intersects(mpsz, preschool))
```

Check the summary statistics of the newly derived *PreSch Count* field by using *summary()* as shown in the code chunk below.

```{r}
summary(mpsz$`PreSch Count`)
```

To list the planning subzone with the most number of pre-school, the *top_n()* of dplyr package is used as shown in the code chunk below.

```{r}
top_n(mpsz, 1, `PreSch Count`)
```

In the code chunk below, another geoprocessing function of sf package called *st_area()* is used to derive the area of each planning subzone.

```{r}
mpsz$Area <- mpsz %>%
  st_area()
```

Next, *mutate()* of dplyr package is used to compute the density by using the code chunk below.

```{r}
mpsz <- mpsz %>%
  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)
```

#### EDA

We will plot a histogram to reveal the distribution of Presch Density. Conventionally, *hist()* of R Graphics will be used as shown in the code chunk below.

```{r}
hist(mpsz$`PreSch Density`)
```

We will use *ggplot2* to provide a better output since it provides customisations.

```{r}
ggplot(data=mpsz, 
       aes(x= as.numeric(`PreSch Density`)))+
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(title = "Are pre-school even distributed in Singapore?",
       subtitle= "There are many planning subzones with a single pre-school, on the other hand, \nthere are seven planning subzones with at least 30 or more pre-schools",
      x = "Pre-school density (per km sq)",
      y = "Frequency")
```

In the code chunk below, appropriate *ggplot2* functions are used to plot a scatterplot showing the relationship between Pre-school Density and Pre-school Count.

```{r}
ggplot(data=mpsz, 
       aes(y = `PreSch Count`, 
           x= as.numeric(`PreSch Density`)))+
  geom_point(color="black", 
             fill="light blue") +
  xlim(0, 40) +
  ylim(0, 40) +
  labs(title = "",
      x = "Pre-school density (per km sq)",
      y = "Pre-school count")
```

# **Reference**

-   [Kam, T. S. Geospatial Data Science with R. R for Geospatial Data Science and Analytics](https://r4gdsa.netlify.app/chap01.html)
